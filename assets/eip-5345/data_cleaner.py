import pandas as pd
import numpy as np
from typing import Optional, List

def remove_duplicates(df: pd.DataFrame, subset: Optional[List[str]] = None) -> pd.DataFrame:
    """
    Remove duplicate rows from DataFrame.
    """
    return df.drop_duplicates(subset=subset, keep='first')

def fill_missing_values(df: pd.DataFrame, strategy: str = 'mean', columns: Optional[List[str]] = None) -> pd.DataFrame:
    """
    Fill missing values using specified strategy.
    """
    df_filled = df.copy()
    
    if columns is None:
        columns = df.columns
    
    for col in columns:
        if df[col].dtype in [np.float64, np.int64]:
            if strategy == 'mean':
                df_filled[col] = df[col].fillna(df[col].mean())
            elif strategy == 'median':
                df_filled[col] = df[col].fillna(df[col].median())
            elif strategy == 'mode':
                df_filled[col] = df[col].fillna(df[col].mode()[0])
            elif strategy == 'zero':
                df_filled[col] = df[col].fillna(0)
        else:
            df_filled[col] = df[col].fillna(df[col].mode()[0] if not df[col].mode().empty else 'Unknown')
    
    return df_filled

def normalize_column(df: pd.DataFrame, column: str) -> pd.DataFrame:
    """
    Normalize a numeric column to range [0, 1].
    """
    df_normalized = df.copy()
    if df[column].dtype in [np.float64, np.int64]:
        col_min = df[column].min()
        col_max = df[column].max()
        if col_max != col_min:
            df_normalized[column] = (df[column] - col_min) / (col_max - col_min)
    return df_normalized

def remove_outliers_iqr(df: pd.DataFrame, column: str, multiplier: float = 1.5) -> pd.DataFrame:
    """
    Remove outliers using IQR method.
    """
    if df[column].dtype in [np.float64, np.int64]:
        Q1 = df[column].quantile(0.25)
        Q3 = df[column].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - multiplier * IQR
        upper_bound = Q3 + multiplier * IQR
        return df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]
    return df

def clean_dataframe(df: pd.DataFrame, 
                    remove_dups: bool = True,
                    fill_na: bool = True,
                    fill_strategy: str = 'mean',
                    normalize_cols: Optional[List[str]] = None,
                    remove_outlier_cols: Optional[List[str]] = None) -> pd.DataFrame:
    """
    Comprehensive data cleaning pipeline.
    """
    cleaned_df = df.copy()
    
    if remove_dups:
        cleaned_df = remove_duplicates(cleaned_df)
    
    if fill_na:
        cleaned_df = fill_missing_values(cleaned_df, strategy=fill_strategy)
    
    if normalize_cols:
        for col in normalize_cols:
            cleaned_df = normalize_column(cleaned_df, col)
    
    if remove_outlier_cols:
        for col in remove_outlier_cols:
            cleaned_df = remove_outliers_iqr(cleaned_df, col)
    
    return cleaned_df
import re
import pandas as pd
from typing import Union, List, Optional

def remove_duplicates(data: Union[List, pd.Series, pd.DataFrame]) -> Union[List, pd.Series, pd.DataFrame]:
    """
    Remove duplicate entries from a list, Series, or DataFrame.
    For DataFrames, it removes duplicate rows.
    """
    if isinstance(data, list):
        return list(dict.fromkeys(data))
    elif isinstance(data, pd.Series):
        return data.drop_duplicates()
    elif isinstance(data, pd.DataFrame):
        return data.drop_duplicates()
    else:
        raise TypeError("Input must be a list, pandas Series, or pandas DataFrame")

def validate_email(email: str) -> bool:
    """
    Validate an email address using a regular expression.
    Returns True if valid, False otherwise.
    """
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))

def normalize_string(text: str, case: str = 'lower') -> str:
    """
    Normalize a string by stripping whitespace and converting case.
    Valid case options: 'lower', 'upper', 'title'.
    """
    text = text.strip()
    if case == 'lower':
        return text.lower()
    elif case == 'upper':
        return text.upper()
    elif case == 'title':
        return text.title()
    else:
        raise ValueError("Case must be 'lower', 'upper', or 'title'")

def fill_missing_values(df: pd.DataFrame, column: str, value: Union[str, int, float]) -> pd.DataFrame:
    """
    Fill missing values in a specified column of a DataFrame with a provided value.
    Returns a new DataFrame with missing values filled.
    """
    df_filled = df.copy()
    df_filled[column] = df_filled[column].fillna(value)
    return df_filled

def filter_by_threshold(data: List[float], threshold: float, above: bool = True) -> List[float]:
    """
    Filter a list of numbers based on a threshold.
    If above is True, keep values >= threshold.
    If above is False, keep values < threshold.
    """
    if above:
        return [x for x in data if x >= threshold]
    else:
        return [x for x in data if x < threshold]